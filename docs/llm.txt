# Repository Structure and Contents
Generated on Fri Sep 19 07:57:38 PM EDT 2025

## Directory Structure

.
├── generate-llm-txt.sh
├── .gitignore
├── qodana.yaml
├── README.md
├── src
│   ├── TaskTracker.Application
│   │   ├── Services
│   │   │   ├── ITodoService.cs
│   │   │   └── TodoService.cs
│   │   └── TaskTracker.Application.csproj
│   ├── TaskTracker.ConsoleApp
│   │   ├── Program.cs
│   │   ├── TaskTracker.ConsoleApp.csproj
│   │   ├── task_tracker.db
│   │   ├── task_tracker.db-shm
│   │   └── task_tracker.db-wal
│   ├── TaskTracker.Domain
│   │   ├── Entities
│   │   │   └── TodoItem.cs
│   │   ├── Repositories
│   │   │   └── ITodoRepository.cs
│   │   └── TaskTracker.Domain.csproj
│   └── TaskTracker.Infrastructure
│       ├── Data
│       │   ├── TodoDbContext.cs
│       │   └── TodoRepository.cs
│       ├── TaskTracker.Infrastructure.csproj
│       └── Telemetry
│           └── TelemetryFactory.cs
├── TaskTracker.sln
└── tests
    └── TaskTracker.Tests
        ├── TaskTracker.Tests.csproj
        ├── TodoRepositoryTests.cs
        └── TodoServiceTests.cs

13 directories, 23 files

## File Contents

### ./generate-llm-txt.sh
```
#!/bin/bash

# Script to generate llm.txt with repo contents for LLM context
# Excludes .git and docs folders, outputs to docs/llm.txt

set -e

# Check if we're in a git repository
if [ ! -d ".git" ]; then
    echo "Error: Not in a git repository root directory"
    exit 1
fi

# Create docs directory if it doesn't exist
mkdir -p docs

# Output file
OUTPUT_FILE="docs/llm.txt"

# Clear/create the output file
> "$OUTPUT_FILE"

echo "Generating repository overview in $OUTPUT_FILE..."

# Add header
{
    echo "# Repository Structure and Contents"
    echo "Generated on $(date)"
    echo ""
    echo "## Directory Structure"
    echo ""
} >> "$OUTPUT_FILE"

# Generate tree structure excluding .git and docs folders
tree -a -I '.git|docs' >> "$OUTPUT_FILE"

{
    echo ""
    echo "## File Contents"
    echo ""
} >> "$OUTPUT_FILE"

# Find all files excluding .git and docs directories
find . -type f \
    -not -path "./.git/*" \
    -not -path "./docs/*" \
    -not -name "*.exe" \
    -not -name "*.dll" \
    -not -name "*.pdb" \
    -not -name "*.cache" \
    -not -path "./bin/*" \
    -not -path "./obj/*" \
    -not -name "*.png" \
    -not -name "*.jpg" \
    -not -name "*.jpeg" \
    -not -name "*.gif" \
    -not -name "*.ico" \
    -not -name "*.pdf" \
    -not -name "*.zip" \
    -not -name "*.tar.gz" \
    | sort | while read -r file; do
    
    # Skip if file is too large (over 1MB)
    if [ $(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo 0) -gt 1048576 ]; then
        {
            echo "### $file"
            echo "*File too large to include (>1MB)*"
            echo ""
        } >> "$OUTPUT_FILE"
        continue
    fi
    
    # Check if file is likely text/readable
    if file "$file" | grep -qE "(text|ASCII|UTF-8|JSON|XML|empty)"; then
        {
            echo "### $file"
            echo '```'
            cat "$file"
            echo '```'
            echo ""
        } >> "$OUTPUT_FILE"
    else
        {
            echo "### $file"
            echo "*Binary file - content not included*"
            echo ""
        } >> "$OUTPUT_FILE"
    fi
done

echo "Repository overview generated successfully in $OUTPUT_FILE"
echo "File size: $(du -h "$OUTPUT_FILE" | cut -f1)"
```

### ./.gitignore
```
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.
##
## Get latest from `dotnet new gitignore`

# dotenv files
.env

# User-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Mono auto generated files
mono_crash.*

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Ww][Ii][Nn]32/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Ll]og/
[Ll]ogs/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUnit
*.VisualState.xml
TestResult.xml
nunit-*.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET
project.lock.json
project.fragment.lock.json
artifacts/

# Tye
.tye/

# ASP.NET Scaffolding
ScaffoldingReadMe.txt

# StyleCop
StyleCopReport.xml

# Files built by Visual Studio
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.tlog
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Coverlet is a free, cross platform Code Coverage Tool
coverage*.json
coverage*.xml
coverage*.info

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these scripts will be unencrypted
PublishScripts/

# NuGet Packages
*.nupkg
# NuGet Symbol Packages
*.snupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx
*.appxbundle
*.appxupload

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!?*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser
*- [Bb]ackup.rdl
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio 6 auto-generated project file (contains which files were open etc.)
*.vbp

# Visual Studio 6 workspace and project file (working project files containing files to include in project)
*.dsw
*.dsp

# Visual Studio 6 technical files
*.ncb
*.aps

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# CodeRush personal settings
.cr/personal

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Local History for Visual Studio
.localhistory/

# Visual Studio History (VSHistory) files
.vshistory/

# BeatPulse healthcheck temp database
healthchecksdb

# Backup folder for Package Reference Convert tool in Visual Studio 2017
MigrationBackup/

# Ionide (cross platform F# VS Code tools) working folder
.ionide/

# Fody - auto-generated XML schema
FodyWeavers.xsd

# VS Code files for those working on multiple tools
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
*.code-workspace

# Local History for Visual Studio Code
.history/

# Windows Installer files from build outputs
*.cab
*.msi
*.msix
*.msm
*.msp

# JetBrains Rider
*.sln.iml
.idea/

##
## Visual studio for Mac
##


# globs
Makefile.in
*.userprefs
*.usertasks
config.make
config.status
aclocal.m4
install-sh
autom4te.cache/
*.tar.gz
tarballs/
test-results/

# Mac bundle stuff
*.dmg
*.app

# content below from: https://github.com/github/gitignore/blob/main/Global/macOS.gitignore
# General
.DS_Store
.AppleDouble
.LSOverride

# Icon must end with two \r
Icon


# Thumbnails
._*

# Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

# content below from: https://github.com/github/gitignore/blob/main/Global/Windows.gitignore
# Windows thumbnail cache files
Thumbs.db
ehthumbs.db
ehthumbs_vista.db

# Dump file
*.stackdump

# Folder config file
[Dd]esktop.ini

# Recycle Bin used on file shares
$RECYCLE.BIN/

# Windows Installer files
*.cab
*.msi
*.msix
*.msm
*.msp

# Windows shortcuts
*.lnk

# Vim temporary swap files
*.swp
```

### ./qodana.yaml
```
#-------------------------------------------------------------------------------#
#               Qodana analysis is configured by qodana.yaml file               #
#             https://www.jetbrains.com/help/qodana/qodana-yaml.html            #
#-------------------------------------------------------------------------------#
version: "1.0"

#Specify IDE code to run analysis without container (Applied in CI/CD pipeline)
ide: QDNET

#Specify inspection profile for code analysis
profile:
  name: qodana.starter

#Enable inspections
#include:
#  - name: <SomeEnabledInspectionId>

#Disable inspections
#exclude:
#  - name: <SomeDisabledInspectionId>
#    paths:
#      - <path/where/not/run/inspection>

#Execute shell command before Qodana execution (Applied in CI/CD pipeline)
#bootstrap: sh ./prepare-qodana.sh

#Install IDE plugins before Qodana execution (Applied in CI/CD pipeline)
#plugins:
#  - id: <plugin.id> #(plugin id can be found at https://plugins.jetbrains.com)

# Quality gate. Will fail the CI/CD pipeline if any condition is not met
# severityThresholds - configures maximum thresholds for different problem severities
# testCoverageThresholds - configures minimum code coverage on a whole project and newly added code
# Code Coverage is available in Ultimate and Ultimate Plus plans
#failureConditions:
#  severityThresholds:
#    any: 15
#    critical: 5
#  testCoverageThresholds:
#    fresh: 70
#    total: 50
```

### ./README.md
```
## Build and Run Instructions

### Prerequisites
- .NET 9 SDK installed
- Visual Studio 2022 or VS Code with C# extension

### Building the Solution

```bash
# Navigate to the solution root directory
cd TaskTracker

# Restore NuGet packages
dotnet restore

# Build the solution
dotnet build

# Run tests
dotnet test
```

### Running the Application

```bash
# Navigate to the console app project
cd src/TaskTracker.ConsoleApp

# Run the application
dotnet run
```

### Using the Application

Once running, you can use these commands:
- `add <title>` - Create a new todo item
- `list` - Show all todo items
- `done <id>` - Mark a todo as complete
- `delete <id>` - Remove a todo item
- `exit` - Quit the application

### Database Files

The application creates two SQLite database files:
1. `task_tracker.db` - Contains todo items and telemetry data (logs, spans)
2. The database is automatically created on first run

### Key Features Implemented

1. **Clean Architecture**: Proper separation of concerns with Domain, Application, Infrastructure, and Presentation layers
2. **Dependency Injection**: Full DI container setup using Microsoft.Extensions.DependencyInjection
3. **Entity Framework Core**: SQLite database with code-first approach
4. **OpenTelemetry**: Complete observability with:
   - Distributed tracing (Activities/Spans)
   - Structured logging
   - Custom SQLite exporters to persist telemetry
5. **Async/Await**: All I/O operations are asynchronous
6. **Unit Testing**: Comprehensive tests using xUnit and in-memory database
7. **Modern C# 13**: File-scoped namespaces, top-level statements, nullable reference types
8. **Error Handling**: Graceful exception handling throughout

This solution demonstrates production-quality patterns and practices for a .NET 9 console application with full observability and testing.


## License
This project is open source and available under the AGPL license.

---
*Notice: This project contains code generated by Large Language Models such as Claude and Gemini. All code is experimental whether explicitly stated or not.*
```

### ./src/TaskTracker.Application/Services/ITodoService.cs
```
using TaskTracker.Domain.Entities;

namespace TaskTracker.Application.Services;

/// <summary>
/// Service abstraction for todo operations
/// </summary>
public interface ITodoService
{
    Task<TodoItem> CreateTodoAsync(string title);
    Task<TodoItem?> GetTodoByIdAsync(int id);
    Task<IEnumerable<TodoItem>> GetAllTodosAsync();
    Task<bool> MarkAsCompleteAsync(int id);
    Task<bool> DeleteTodoAsync(int id);
}
```

### ./src/TaskTracker.Application/Services/TodoService.cs
```
using System.Diagnostics;
using Microsoft.Extensions.Logging;
using TaskTracker.Application.Services;
using TaskTracker.Domain.Entities;
using TaskTracker.Domain.Repositories;

namespace TaskTracker.Application.Services;

/// <summary>
/// Implementation of todo service with OpenTelemetry instrumentation
/// </summary>
public class TodoService : ITodoService
{
    private readonly ITodoRepository _repository;
    private readonly ILogger<TodoService> _logger;
    private static readonly ActivitySource ActivitySource = new("TaskTracker.Application");

    public TodoService(ITodoRepository repository, ILogger<TodoService> logger)
    {
        _repository = repository ?? throw new ArgumentNullException(nameof(repository));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task<TodoItem> CreateTodoAsync(string title)
    {
        // Create a new activity (span) for tracing
        using var activity = ActivitySource.StartActivity("CreateTodo");
        activity?.SetTag("todo.title", title);

        try
        {
            _logger.LogInformation("Creating new todo item with title: {Title}", title);
            activity?.AddEvent(new ActivityEvent("CreatingTodoItem"));

            var item = new TodoItem
            {
                Title = title,
                IsDone = false,
                CreatedAtUtc = DateTime.UtcNow
            };

            var created = await _repository.AddAsync(item);

            activity?.SetTag("todo.id", created.Id);
            activity?.AddEvent(new ActivityEvent("TodoItemCreated"));
            _logger.LogInformation("Todo item created successfully with ID: {Id}", created.Id);

            return created;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creating todo item");
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            throw;
        }
    }

    public async Task<TodoItem?> GetTodoByIdAsync(int id)
    {
        using var activity = ActivitySource.StartActivity("GetTodoById");
        activity?.SetTag("todo.id", id);

        try
        {
            _logger.LogDebug("Retrieving todo item with ID: {Id}", id);
            var item = await _repository.GetByIdAsync(id);

            if (item != null)
            {
                activity?.AddEvent(new ActivityEvent("TodoItemFound"));
                _logger.LogDebug("Todo item found with ID: {Id}", id);
            }
            else
            {
                activity?.AddEvent(new ActivityEvent("TodoItemNotFound"));
                _logger.LogWarning("Todo item not found with ID: {Id}", id);
            }

            return item;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving todo item with ID: {Id}", id);
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            throw;
        }
    }

    public async Task<IEnumerable<TodoItem>> GetAllTodosAsync()
    {
        using var activity = ActivitySource.StartActivity("GetAllTodos");

        try
        {
            _logger.LogDebug("Retrieving all todo items");
            activity?.AddEvent(new ActivityEvent("RetrievingAllItems"));

            var items = await _repository.GetAllAsync();
            var itemsList = items.ToList();

            activity?.SetTag("todo.count", itemsList.Count);
            activity?.AddEvent(new ActivityEvent("ItemsRetrieved"));
            _logger.LogInformation("Retrieved {Count} todo items", itemsList.Count);

            return itemsList;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving all todo items");
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            throw;
        }
    }

    public async Task<bool> MarkAsCompleteAsync(int id)
    {
        using var activity = ActivitySource.StartActivity("MarkTodoAsComplete");
        activity?.SetTag("todo.id", id);

        try
        {
            _logger.LogInformation("Marking todo item as complete with ID: {Id}", id);
            activity?.AddEvent(new ActivityEvent("MarkingAsComplete"));

            var item = await _repository.GetByIdAsync(id);
            if (item == null)
            {
                activity?.AddEvent(new ActivityEvent("TodoItemNotFound"));
                _logger.LogWarning("Cannot mark as complete - todo item not found with ID: {Id}", id);
                return false;
            }

            item.IsDone = true;
            await _repository.UpdateAsync(item);

            activity?.AddEvent(new ActivityEvent("MarkedAsComplete"));
            _logger.LogInformation("Todo item marked as complete with ID: {Id}", id);

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error marking todo item as complete with ID: {Id}", id);
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            throw;
        }
    }

    public async Task<bool> DeleteTodoAsync(int id)
    {
        using var activity = ActivitySource.StartActivity("DeleteTodo");
        activity?.SetTag("todo.id", id);

        try
        {
            _logger.LogInformation("Deleting todo item with ID: {Id}", id);
            activity?.AddEvent(new ActivityEvent("DeletingTodoItem"));

            var item = await _repository.GetByIdAsync(id);
            if (item == null)
            {
                activity?.AddEvent(new ActivityEvent("TodoItemNotFound"));
                _logger.LogWarning("Cannot delete - todo item not found with ID: {Id}", id);
                return false;
            }

            await _repository.DeleteAsync(id);

            activity?.AddEvent(new ActivityEvent("TodoItemDeleted"));
            _logger.LogInformation("Todo item deleted successfully with ID: {Id}", id);

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error deleting todo item with ID: {Id}", id);
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            throw;
        }
    }
}
```

### ./src/TaskTracker.Application/TaskTracker.Application.csproj
```
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>13.0</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\TaskTracker.Domain\TaskTracker.Domain.csproj" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="9.0.0" />
    <PackageReference Include="System.Diagnostics.DiagnosticSource" Version="9.0.0" />
  </ItemGroup>

</Project>
```

### ./src/TaskTracker.ConsoleApp/Program.cs
```
using System.Diagnostics;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using TaskTracker.Application.Services;
using TaskTracker.Domain.Repositories;
using TaskTracker.Infrastructure.Data;
using TaskTracker.Infrastructure.Telemetry;

// Create Activity Source for the console app
var activitySource = new ActivitySource("TaskTracker.ConsoleApp");

// Build the host with dependency injection
var host = Host.CreateDefaultBuilder(args)
    .ConfigureServices((context, services) =>
    {
        // Connection string for SQLite database
        const string connectionString = "Data Source=task_tracker.db";
        
        // Configure Entity Framework with SQLite
        services.AddDbContext<TodoDbContext>(options =>
            options.UseSqlite(connectionString));
        
        // Configure OpenTelemetry with SQLite storage
        TelemetryFactory.ConfigureOpenTelemetry(services, connectionString);
        
        // Register repositories (Infrastructure layer)
        services.AddScoped<ITodoRepository, TodoRepository>();
        
        // Register services (Application layer)
        services.AddScoped<ITodoService, TodoService>();
        
        // Configure logging
        services.AddLogging(builder =>
        {
            builder.SetMinimumLevel(LogLevel.Information);
            builder.AddConsole();
        });
    })
    .Build();

// Ensure database is created
using (var scope = host.Services.CreateScope())
{
    var dbContext = scope.ServiceProvider.GetRequiredService<TodoDbContext>();
    await dbContext.Database.EnsureCreatedAsync();
    
    var telemetryContext = scope.ServiceProvider.GetRequiredService<TelemetryDbContext>();
    await telemetryContext.Database.EnsureCreatedAsync();
}

// Start root activity for the entire application run
using var rootActivity = activitySource.StartActivity("ConsoleApp.Run");
rootActivity?.SetTag("app.start_time", DateTime.UtcNow.ToString("O"));

// Get logger and service
var logger = host.Services.GetRequiredService<ILogger<Program>>();
var todoService = host.Services.GetRequiredService<ITodoService>();

logger.LogInformation("TaskTracker Console Application started");
Console.WriteLine("=== TaskTracker Console Application ===");
Console.WriteLine("Commands:");
Console.WriteLine("  add <title>  - Add a new todo item");
Console.WriteLine("  list         - List all todo items");
Console.WriteLine("  done <id>    - Mark a todo item as complete");
Console.WriteLine("  delete <id>  - Delete a todo item");
Console.WriteLine("  exit         - Exit the application");
Console.WriteLine();

var running = true;
while (running)
{
    try
    {
        Console.Write("> ");
        var input = Console.ReadLine()?.Trim();
        
        if (string.IsNullOrEmpty(input))
            continue;
        
        var parts = input.Split(' ', 2, StringSplitOptions.RemoveEmptyEntries);
        var command = parts[0].ToLowerInvariant();
        
        // Create activity for each command
        using var commandActivity = activitySource.StartActivity($"Command.{command}");
        commandActivity?.SetTag("command.type", command);
        
        switch (command)
        {
            case "add" when parts.Length > 1:
                {
                    var title = parts[1];
                    commandActivity?.SetTag("command.title", title);
                    
                    var todo = await todoService.CreateTodoAsync(title);
                    Console.WriteLine($"✅ Created todo #{todo.Id}: {todo.Title}");
                    logger.LogInformation("User created todo item #{Id}", todo.Id);
                }
                break;
                
            case "list":
                {
                    var todos = await todoService.GetAllTodosAsync();
                    var todoList = todos.ToList();
                    
                    commandActivity?.SetTag("command.result_count", todoList.Count);
                    
                    if (!todoList.Any())
                    {
                        Console.WriteLine("No todo items found.");
                    }
                    else
                    {
                        Console.WriteLine("\nTodo Items:");
                        Console.WriteLine("===========");
                        foreach (var todo in todoList)
                        {
                            var status = todo.IsDone ? "✅" : "⬜";
                            Console.WriteLine($"{status} #{todo.Id}: {todo.Title} (Created: {todo.CreatedAtUtc:yyyy-MM-dd HH:mm})");
                        }
                        Console.WriteLine();
                    }
                    logger.LogInformation("User listed {Count} todo items", todoList.Count);
                }
                break;
                
            case "done" when parts.Length > 1 && int.TryParse(parts[1], out var id):
                {
                    commandActivity?.SetTag("command.id", id);
                    
                    var success = await todoService.MarkAsCompleteAsync(id);
                    if (success)
                    {
                        Console.WriteLine($"✅ Marked todo #{id} as complete");
                        logger.LogInformation("User marked todo #{Id} as complete", id);
                    }
                    else
                    {
                        Console.WriteLine($"❌ Todo #{id} not found");
                        logger.LogWarning("User tried to mark non-existent todo #{Id} as complete", id);
                    }
                }
                break;
                
            case "delete" when parts.Length > 1 && int.TryParse(parts[1], out var id):
                {
                    commandActivity?.SetTag("command.id", id);
                    
                    var success = await todoService.DeleteTodoAsync(id);
                    if (success)
                    {
                        Console.WriteLine($"✅ Deleted todo #{id}");
                        logger.LogInformation("User deleted todo #{Id}", id);
                    }
                    else
                    {
                        Console.WriteLine($"❌ Todo #{id} not found");
                        logger.LogWarning("User tried to delete non-existent todo #{Id}", id);
                    }
                }
                break;
                
            case "exit":
                running = false;
                Console.WriteLine("Goodbye!");
                logger.LogInformation("User exited the application");
                break;
                
            default:
                Console.WriteLine("❌ Invalid command. Type 'exit' to quit.");
                commandActivity?.SetStatus(ActivityStatusCode.Error, "Invalid command");
                break;
        }
    }
    catch (Exception ex)
    {
        // Handle any unexpected exceptions gracefully
        Console.WriteLine($"❌ An error occurred: {ex.Message}");
        logger.LogError(ex, "Unhandled exception in command loop");
    }
}

rootActivity?.SetTag("app.end_time", DateTime.UtcNow.ToString("O"));
rootActivity?.AddEvent(new ActivityEvent("ApplicationShutdown"));

// Dispose of the host
await host.StopAsync();
host.Dispose();
```

### ./src/TaskTracker.ConsoleApp/TaskTracker.ConsoleApp.csproj
```
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>13.0</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\TaskTracker.Application\TaskTracker.Application.csproj" />
    <ProjectReference Include="..\TaskTracker.Infrastructure\TaskTracker.Infrastructure.csproj" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
  </ItemGroup>

</Project>
```

### ./src/TaskTracker.ConsoleApp/task_tracker.db
*Binary file - content not included*

### ./src/TaskTracker.ConsoleApp/task_tracker.db-shm
*Binary file - content not included*

### ./src/TaskTracker.ConsoleApp/task_tracker.db-wal
*Binary file - content not included*

### ./src/TaskTracker.Domain/Entities/TodoItem.cs
```
namespace TaskTracker.Domain.Entities;

/// <summary>
/// Represents a todo item entity in the domain model
/// </summary>
public class TodoItem
{
    public int Id { get; set; }
    public required string Title { get; set; }
    public bool IsDone { get; set; }
    public DateTime CreatedAtUtc { get; set; }
}
```

### ./src/TaskTracker.Domain/Repositories/ITodoRepository.cs
```
using TaskTracker.Domain.Entities;

namespace TaskTracker.Domain.Repositories;

/// <summary>
/// Repository abstraction for TodoItem operations
/// </summary>
public interface ITodoRepository
{
    Task<TodoItem?> GetByIdAsync(int id);
    Task<IEnumerable<TodoItem>> GetAllAsync();
    Task<TodoItem> AddAsync(TodoItem item);
    Task UpdateAsync(TodoItem item);
    Task DeleteAsync(int id);
}
```

### ./src/TaskTracker.Domain/TaskTracker.Domain.csproj
```
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>13.0</LangVersion>
  </PropertyGroup>

</Project>
```

### ./src/TaskTracker.Infrastructure/Data/TodoDbContext.cs
```
using Microsoft.EntityFrameworkCore;
using TaskTracker.Domain.Entities;

namespace TaskTracker.Infrastructure.Data;

/// <summary>
/// Entity Framework Core database context for the application
/// </summary>
public class TodoDbContext : DbContext
{
    public TodoDbContext(DbContextOptions<TodoDbContext> options) : base(options)
    {
    }

    public DbSet<TodoItem> TodoItems { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // Configure TodoItem entity
        modelBuilder.Entity<TodoItem>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Title).IsRequired().HasMaxLength(500);
            entity.Property(e => e.IsDone).IsRequired();
            entity.Property(e => e.CreatedAtUtc).IsRequired();
            entity.HasIndex(e => e.CreatedAtUtc);
        });
    }
}
```

### ./src/TaskTracker.Infrastructure/Data/TodoRepository.cs
```
using Microsoft.EntityFrameworkCore;
using TaskTracker.Domain.Entities;
using TaskTracker.Domain.Repositories;

namespace TaskTracker.Infrastructure.Data;

/// <summary>
/// Repository implementation using Entity Framework Core
/// </summary>
public class TodoRepository : ITodoRepository
{
    private readonly TodoDbContext _context;

    public TodoRepository(TodoDbContext context)
    {
        _context = context ?? throw new ArgumentNullException(nameof(context));
    }

    public async Task<TodoItem?> GetByIdAsync(int id)
    {
        return await _context.TodoItems
            .AsNoTracking()
            .FirstOrDefaultAsync(t => t.Id == id);
    }

    public async Task<IEnumerable<TodoItem>> GetAllAsync()
    {
        return await _context.TodoItems
            .AsNoTracking()
            .OrderByDescending(t => t.CreatedAtUtc)
            .ToListAsync();
    }

    public async Task<TodoItem> AddAsync(TodoItem item)
    {
        ArgumentNullException.ThrowIfNull(item);

        _context.TodoItems.Add(item);
        await _context.SaveChangesAsync();
        return item;
    }

    public async Task UpdateAsync(TodoItem item)
    {
        ArgumentNullException.ThrowIfNull(item);

        _context.TodoItems.Update(item);
        await _context.SaveChangesAsync();
    }

    public async Task DeleteAsync(int id)
    {
        var item = await _context.TodoItems.FindAsync(id);
        if (item != null)
        {
            _context.TodoItems.Remove(item);
            await _context.SaveChangesAsync();
        }
    }
}
```

### ./src/TaskTracker.Infrastructure/TaskTracker.Infrastructure.csproj
```
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>13.0</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\TaskTracker.Application\TaskTracker.Application.csproj" />
    <ProjectReference Include="..\TaskTracker.Domain\TaskTracker.Domain.csproj" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore.Sqlite" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0" />
    <PackageReference Include="OpenTelemetry" Version="1.10.0" />
    <PackageReference Include="OpenTelemetry.Exporter.Console" Version="1.10.0" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" Version="1.10.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.10.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.EntityFrameworkCore" Version="1.0.0-rc.1" />
  </ItemGroup>

</Project>
```

### ./src/TaskTracker.Infrastructure/Telemetry/TelemetryFactory.cs
```
using System.Diagnostics;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Logs;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;

namespace TaskTracker.Infrastructure.Telemetry;

/// <summary>
/// Factory for configuring OpenTelemetry with SQLite storage
/// </summary>
public static class TelemetryFactory
{
    public static void ConfigureOpenTelemetry(IServiceCollection services, string connectionString)
    {
        // Configure resource attributes for all telemetry
        var resourceBuilder = ResourceBuilder.CreateDefault()
            .AddService(
                serviceName: "TaskTracker",
                serviceVersion: "1.0.0",
                serviceInstanceId: Environment.MachineName);

        // Add custom SQLite exporter service
        services.AddSingleton<SqliteTelemetryExporter>();
        services.AddDbContext<TelemetryDbContext>(options =>
            options.UseSqlite(connectionString));

        // Configure OpenTelemetry
        services.AddOpenTelemetry()
            .ConfigureResource(resource => resource.AddService("TaskTracker"))
            .WithTracing(tracing =>
            {
                tracing
                    .SetResourceBuilder(resourceBuilder)
                    .AddSource("TaskTracker.Application")
                    .AddEntityFrameworkCoreInstrumentation(options =>
                    {
                        options.SetDbStatementForText = true;
                    })
                    .AddConsoleExporter()
                    .AddProcessor(new SqliteBatchActivityProcessor(services.BuildServiceProvider()));
            })
            .WithMetrics(metrics =>
            {
                metrics
                    .SetResourceBuilder(resourceBuilder)
                    .AddMeter("TaskTracker")
                    .AddConsoleExporter();
            });

        // Configure logging to use OpenTelemetry
        services.AddLogging(builder =>
        {
            builder.AddOpenTelemetry(options =>
            {
                options.SetResourceBuilder(resourceBuilder);
                options.AddConsoleExporter();
                options.AddProcessor(new SqliteBatchLogProcessor(services.BuildServiceProvider()));
            });
        });
    }
}

/// <summary>
/// DbContext for storing telemetry data
/// </summary>
public class TelemetryDbContext : DbContext
{
    public TelemetryDbContext(DbContextOptions<TelemetryDbContext> options) : base(options) { }

    public DbSet<LogEntry> Logs { get; set; }
    public DbSet<SpanEntry> Spans { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<LogEntry>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Timestamp).IsRequired();
            entity.Property(e => e.Level).IsRequired();
            entity.Property(e => e.Message).IsRequired();
            entity.HasIndex(e => e.Timestamp);
        });

        modelBuilder.Entity<SpanEntry>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.TraceId).IsRequired();
            entity.Property(e => e.SpanId).IsRequired();
            entity.Property(e => e.OperationName).IsRequired();
            entity.Property(e => e.StartTime).IsRequired();
            entity.HasIndex(e => e.StartTime);
        });
    }
}

/// <summary>
/// Entity for storing log entries
/// </summary>
public class LogEntry
{
    public int Id { get; set; }
    public DateTime Timestamp { get; set; }
    public string Level { get; set; } = string.Empty;
    public string Message { get; set; } = string.Empty;
    public string? Category { get; set; }
    public string? Exception { get; set; }
    public string? Properties { get; set; }
}

/// <summary>
/// Entity for storing span entries
/// </summary>
public class SpanEntry
{
    public int Id { get; set; }
    public string TraceId { get; set; } = string.Empty;
    public string SpanId { get; set; } = string.Empty;
    public string? ParentSpanId { get; set; }
    public string OperationName { get; set; } = string.Empty;
    public DateTime StartTime { get; set; }
    public DateTime? EndTime { get; set; }
    public long DurationMs { get; set; }
    public string Status { get; set; } = string.Empty;
    public string? Attributes { get; set; }
    public string? Events { get; set; }
}

/// <summary>
/// Custom SQLite exporter for telemetry data
/// </summary>
public class SqliteTelemetryExporter
{
    private readonly TelemetryDbContext _context;

    public SqliteTelemetryExporter(TelemetryDbContext context)
    {
        _context = context;
        _context.Database.EnsureCreated();
    }

    public async Task ExportLogsAsync(IEnumerable<LogRecord> logs)
    {
        foreach (var log in logs)
        {
            var entry = new LogEntry
            {
                Timestamp = log.Timestamp,
                Level = log.LogLevel.ToString(),
                Message = log.FormattedMessage ?? string.Empty,
                Category = log.CategoryName,
                Exception = log.Exception?.ToString(),
                Properties = System.Text.Json.JsonSerializer.Serialize(log.Attributes)
            };
            _context.Logs.Add(entry);
        }
        await _context.SaveChangesAsync();
    }

    public async Task ExportSpansAsync(IEnumerable<Activity> spans)
    {
        foreach (var span in spans)
        {
            var entry = new SpanEntry
            {
                TraceId = span.TraceId.ToString(),
                SpanId = span.SpanId.ToString(),
                ParentSpanId = span.ParentSpanId.ToString(),
                OperationName = span.DisplayName,
                StartTime = span.StartTimeUtc,
                EndTime = span.StartTimeUtc.Add(span.Duration),
                DurationMs = (long)span.Duration.TotalMilliseconds,
                Status = span.Status.ToString(),
                Attributes = System.Text.Json.JsonSerializer.Serialize(span.Tags),
                Events = System.Text.Json.JsonSerializer.Serialize(span.Events.Select(e => new { e.Name, e.Timestamp }))
            };
            _context.Spans.Add(entry);
        }
        await _context.SaveChangesAsync();
    }
}

/// <summary>
/// Custom batch processor for activities
/// </summary>
public class SqliteBatchActivityProcessor : BaseProcessor<Activity>
{
    private readonly SqliteTelemetryExporter _exporter;

    public SqliteBatchActivityProcessor(IServiceProvider serviceProvider) : base()
    {
        var scope = serviceProvider.CreateScope();
        _exporter = scope.ServiceProvider.GetRequiredService<SqliteTelemetryExporter>();
    }

    public override void OnEnd(Activity data)
    {
        if (data != null)
        {
            Task.Run(async () => await _exporter.ExportSpansAsync(new[] { data }));
        }
    }
}

/// <summary>
/// Custom batch processor for logs
/// </summary>
public class SqliteBatchLogProcessor : BaseProcessor<LogRecord>
{
    private readonly SqliteTelemetryExporter _exporter;

    public SqliteBatchLogProcessor(IServiceProvider serviceProvider) : base()
    {
        var scope = serviceProvider.CreateScope();
        _exporter = scope.ServiceProvider.GetRequiredService<SqliteTelemetryExporter>();
    }

    public override void OnEnd(LogRecord data)
    {
        if (data != null)
        {
            Task.Run(async () => await _exporter.ExportLogsAsync(new[] { data }));
        }
    }
}
```

### ./TaskTracker.sln
```
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "src", "src", "{8B5C5A7D-4F9E-4B2A-9C1F-7E8A9B3D5C4A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TaskTracker.Domain", "src\TaskTracker.Domain\TaskTracker.Domain.csproj", "{A1B2C3D4-E5F6-7890-1234-567890ABCDEF}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TaskTracker.Application", "src\TaskTracker.Application\TaskTracker.Application.csproj", "{B2C3D4E5-F607-8901-2345-678901BCDEF0}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TaskTracker.Infrastructure", "src\TaskTracker.Infrastructure\TaskTracker.Infrastructure.csproj", "{C3D4E5F6-0718-9012-3456-789012CDEF01}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TaskTracker.ConsoleApp", "src\TaskTracker.ConsoleApp\TaskTracker.ConsoleApp.csproj", "{D4E5F607-1829-0123-4567-890123DEF012}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "tests", "tests", "{9C6D6B8E-5G0F-5C3B-0D2G-8F9B0C4E6D5B}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TaskTracker.Tests", "tests\TaskTracker.Tests\TaskTracker.Tests.csproj", "{E5F60718-293A-1234-5678-901234EF0123}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A1B2C3D4-E5F6-7890-1234-567890ABCDEF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A1B2C3D4-E5F6-7890-1234-567890ABCDEF}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A1B2C3D4-E5F6-7890-1234-567890ABCDEF}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A1B2C3D4-E5F6-7890-1234-567890ABCDEF}.Release|Any CPU.Build.0 = Release|Any CPU
		{B2C3D4E5-F607-8901-2345-678901BCDEF0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B2C3D4E5-F607-8901-2345-678901BCDEF0}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B2C3D4E5-F607-8901-2345-678901BCDEF0}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B2C3D4E5-F607-8901-2345-678901BCDEF0}.Release|Any CPU.Build.0 = Release|Any CPU
		{C3D4E5F6-0718-9012-3456-789012CDEF01}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C3D4E5F6-0718-9012-3456-789012CDEF01}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C3D4E5F6-0718-9012-3456-789012CDEF01}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C3D4E5F6-0718-9012-3456-789012CDEF01}.Release|Any CPU.Build.0 = Release|Any CPU
		{D4E5F607-1829-0123-4567-890123DEF012}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D4E5F607-1829-0123-4567-890123DEF012}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D4E5F607-1829-0123-4567-890123DEF012}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D4E5F607-1829-0123-4567-890123DEF012}.Release|Any CPU.Build.0 = Release|Any CPU
		{E5F60718-293A-1234-5678-901234EF0123}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E5F60718-293A-1234-5678-901234EF0123}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E5F60718-293A-1234-5678-901234EF0123}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E5F60718-293A-1234-5678-901234EF0123}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{A1B2C3D4-E5F6-7890-1234-567890ABCDEF} = {8B5C5A7D-4F9E-4B2A-9C1F-7E8A9B3D5C4A}
		{B2C3D4E5-F607-8901-2345-678901BCDEF0} = {8B5C5A7D-4F9E-4B2A-9C1F-7E8A9B3D5C4A}
		{C3D4E5F6-0718-9012-3456-789012CDEF01} = {8B5C5A7D-4F9E-4B2A-9C1F-7E8A9B3D5C4A}
		{D4E5F607-1829-0123-4567-890123DEF012} = {8B5C5A7D-4F9E-4B2A-9C1F-7E8A9B3D5C4A}
		{E5F60718-293A-1234-5678-901234EF0123} = {9C6D6B8E-5G0F-5C3B-0D2G-8F9B0C4E6D5B}
	EndGlobalSection
EndGlobal
```

### ./tests/TaskTracker.Tests/TaskTracker.Tests.csproj
```
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>13.0</LangVersion>
    <IsPackable>false</IsPackable>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.12.0" />
    <PackageReference Include="xunit" Version="2.9.2" />
    <PackageReference Include="xunit.runner.visualstudio" Version="3.0.0">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" Version="9.0.0" />
    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="9.0.0" />
    <PackageReference Include="Moq" Version="4.20.72" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\src\TaskTracker.Application\TaskTracker.Application.csproj" />
    <ProjectReference Include="..\..\src\TaskTracker.Infrastructure\TaskTracker.Infrastructure.csproj" />
  </ItemGroup>

</Project>
```

### ./tests/TaskTracker.Tests/TodoRepositoryTests.cs
```
using Microsoft.EntityFrameworkCore;
using TaskTracker.Domain.Entities;
using TaskTracker.Infrastructure.Data;
using Xunit;

namespace TaskTracker.Tests;

/// <summary>
/// Integration tests for TodoRepository with in-memory database
/// </summary>
public class TodoRepositoryTests : IDisposable
{
    private readonly TodoDbContext _context;
    private readonly TodoRepository _repository;

    public TodoRepositoryTests()
    {
        var options = new DbContextOptionsBuilder<TodoDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;

        _context = new TodoDbContext(options);
        _repository = new TodoRepository(_context);
    }

    [Fact]
    public async Task AddAsync_ValidItem_ReturnsItemWithId()
    {
        // Arrange
        var item = new TodoItem
        {
            Title = "Test Item",
            IsDone = false,
            CreatedAtUtc = DateTime.UtcNow
        };

        // Act
        var result = await _repository.AddAsync(item);

        // Assert
        Assert.NotNull(result);
        Assert.True(result.Id > 0);
        Assert.Equal("Test Item", result.Title);
    }

    [Fact]
    public async Task GetByIdAsync_ExistingItem_ReturnsItem()
    {
        // Arrange
        var item = new TodoItem
        {
            Title = "Test Item",
            IsDone = false,
            CreatedAtUtc = DateTime.UtcNow
        };
        var added = await _repository.AddAsync(item);

        // Act
        var result = await _repository.GetByIdAsync(added.Id);

        // Assert
        Assert.NotNull(result);
        Assert.Equal(added.Id, result.Id);
        Assert.Equal(added.Title, result.Title);
    }

    [Fact]
    public async Task UpdateAsync_ExistingItem_UpdatesSuccessfully()
    {
        // Arrange
        var item = new TodoItem
        {
            Title = "Original Title",
            IsDone = false,
            CreatedAtUtc = DateTime.UtcNow
        };
        var added = await _repository.AddAsync(item);

        // Act
        added.Title = "Updated Title";
        added.IsDone = true;
        await _repository.UpdateAsync(added);

        // Assert
        var updated = await _repository.GetByIdAsync(added.Id);
        Assert.NotNull(updated);
        Assert.Equal("Updated Title", updated.Title);
        Assert.True(updated.IsDone);
    }

    [Fact]
    public async Task DeleteAsync_ExistingItem_RemovesItem()
    {
        // Arrange
        var item = new TodoItem
        {
            Title = "To Delete",
            IsDone = false,
            CreatedAtUtc = DateTime.UtcNow
        };
        var added = await _repository.AddAsync(item);

        // Act
        await _repository.DeleteAsync(added.Id);

        // Assert
        var deleted = await _repository.GetByIdAsync(added.Id);
        Assert.Null(deleted);
    }

    [Fact]
    public async Task GetAllAsync_ReturnsAllItemsOrderedByDate()
    {
        // Arrange
        var item1 = new TodoItem
        {
            Title = "First",
            IsDone = false,
            CreatedAtUtc = DateTime.UtcNow.AddMinutes(-2)
        };
        var item2 = new TodoItem
        {
            Title = "Second",
            IsDone = false,
            CreatedAtUtc = DateTime.UtcNow.AddMinutes(-1)
        };
        var item3 = new TodoItem
        {
            Title = "Third",
            IsDone = false,
            CreatedAtUtc = DateTime.UtcNow
        };

        await _repository.AddAsync(item1);
        await _repository.AddAsync(item2);
        await _repository.AddAsync(item3);

        // Act
        var result = await _repository.GetAllAsync();
        var items = result.ToList();

        // Assert
        Assert.Equal(3, items.Count);
        Assert.Equal("Third", items[0].Title); // Most recent first
        Assert.Equal("Second", items[1].Title);
        Assert.Equal("First", items[2].Title);
    }

    public void Dispose()
    {
        _context.Dispose();
    }
}
```

### ./tests/TaskTracker.Tests/TodoServiceTests.cs
```
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Moq;
using TaskTracker.Application.Services;
using TaskTracker.Domain.Entities;
using TaskTracker.Infrastructure.Data;
using Xunit;

namespace TaskTracker.Tests;

/// <summary>
/// Unit tests for TodoService using in-memory database
/// </summary>
public class TodoServiceTests : IDisposable
{
    private readonly TodoDbContext _context;
    private readonly TodoRepository _repository;
    private readonly TodoService _service;
    private readonly Mock<ILogger<TodoService>> _loggerMock;

    public TodoServiceTests()
    {
        // Setup in-memory database for testing
        var options = new DbContextOptionsBuilder<TodoDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;

        _context = new TodoDbContext(options);
        _repository = new TodoRepository(_context);
        _loggerMock = new Mock<ILogger<TodoService>>();
        _service = new TodoService(_repository, _loggerMock.Object);
    }

    [Fact]
    public async Task CreateTodoAsync_ValidTitle_ReturnsTodoItem()
    {
        // Arrange
        const string title = "Test Todo Item";

        // Act
        var result = await _service.CreateTodoAsync(title);

        // Assert
        Assert.NotNull(result);
        Assert.Equal(title, result.Title);
        Assert.False(result.IsDone);
        Assert.True(result.Id > 0);
        Assert.True(result.CreatedAtUtc > DateTime.MinValue);
    }

    [Fact]
    public async Task GetTodoByIdAsync_ExistingId_ReturnsTodoItem()
    {
        // Arrange
        var todo = await _service.CreateTodoAsync("Test Item");

        // Act
        var result = await _service.GetTodoByIdAsync(todo.Id);

        // Assert
        Assert.NotNull(result);
        Assert.Equal(todo.Id, result.Id);
        Assert.Equal(todo.Title, result.Title);
    }

    [Fact]
    public async Task GetTodoByIdAsync_NonExistingId_ReturnsNull()
    {
        // Act
        var result = await _service.GetTodoByIdAsync(999);

        // Assert
        Assert.Null(result);
    }

    [Fact]
    public async Task GetAllTodosAsync_MultipleItems_ReturnsAll()
    {
        // Arrange
        await _service.CreateTodoAsync("Item 1");
        await _service.CreateTodoAsync("Item 2");
        await _service.CreateTodoAsync("Item 3");

        // Act
        var result = await _service.GetAllTodosAsync();
        var items = result.ToList();

        // Assert
        Assert.Equal(3, items.Count);
        Assert.Contains(items, i => i.Title == "Item 1");
        Assert.Contains(items, i => i.Title == "Item 2");
        Assert.Contains(items, i => i.Title == "Item 3");
    }

    [Fact]
    public async Task GetAllTodosAsync_NoItems_ReturnsEmptyList()
    {
        // Act
        var result = await _service.GetAllTodosAsync();

        // Assert
        Assert.NotNull(result);
        Assert.Empty(result);
    }

    [Fact]
    public async Task MarkAsCompleteAsync_ExistingId_ReturnsTrue()
    {
        // Arrange
        var todo = await _service.CreateTodoAsync("Test Item");

        // Act
        var result = await _service.MarkAsCompleteAsync(todo.Id);

        // Assert
        Assert.True(result);

        // Verify the item is actually marked as done
        var updatedTodo = await _service.GetTodoByIdAsync(todo.Id);
        Assert.NotNull(updatedTodo);
        Assert.True(updatedTodo.IsDone);
    }

    [Fact]
    public async Task MarkAsCompleteAsync_NonExistingId_ReturnsFalse()
    {
        // Act
        var result = await _service.MarkAsCompleteAsync(999);

        // Assert
        Assert.False(result);
    }

    [Fact]
    public async Task DeleteTodoAsync_ExistingId_ReturnsTrue()
    {
        // Arrange
        var todo = await _service.CreateTodoAsync("Test Item");

        // Act
        var result = await _service.DeleteTodoAsync(todo.Id);

        // Assert
        Assert.True(result);

        // Verify the item is actually deleted
        var deletedTodo = await _service.GetTodoByIdAsync(todo.Id);
        Assert.Null(deletedTodo);
    }

    [Fact]
    public async Task DeleteTodoAsync_NonExistingId_ReturnsFalse()
    {
        // Act
        var result = await _service.DeleteTodoAsync(999);

        // Assert
        Assert.False(result);
    }

    [Fact]
    public async Task CreateTodoAsync_LogsInformation()
    {
        // Arrange
        const string title = "Test Item";

        // Act
        await _service.CreateTodoAsync(title);

        // Assert - Verify logging was called
        _loggerMock.Verify(
            x => x.Log(
                LogLevel.Information,
                It.IsAny<EventId>(),
                It.Is<It.IsAnyType>((o, t) => o.ToString()!.Contains("Creating new todo item")),
                It.IsAny<Exception>(),
                It.IsAny<Func<It.IsAnyType, Exception?, string>>()),
            Times.Once);
    }

    public void Dispose()
    {
        _context.Dispose();
    }
}
```

